Module
======

Модули являются неотъемлемой частью архитектуры любого надежного приложения и,
как правило, помогают в сохранении фрагментов кода для проекта разделенными, и организованными.

В JavaScript существует несколько вариантов реализации модулей. К ним относятся:

* Паттерн "Модуль"
* Литерал объекта
* Модули AMD
* Модули CommonJS
* Модули ECMAScript 2016

Литералы объектов
-----------------

В объектной литеральной нотации объект описывается как набор разделенных запятыми пар имя / значение, заключенных в фигурные скобки ({}). Имена внутри объекта могут быть строками или идентификаторами, за которыми следует двоеточие. После конечной пары имя / значение в объекте не должно быть запятой, так как это может привести к ошибкам.

```
var myObjectLiteral = {
    variableKey: variableValue,
    functionKey: function () {
      // ...
    }
};
```

Литералы объектов не требуют инстанциирования с использованием оператора new. Вне объекта новые члены могут быть добавлены к нему, используя присваивание следующим образом: myModule.property = "someValue"; Ниже мы можем видеть более полный пример модуля, определенного с использованием литеральной нотации:

```
var myModule = {

  myProperty: "someValue",

  // object literals can contain properties and methods.
  // e.g we can define a further object for module configuration:
  myConfig: {
    useCaching: true,
    language: "en"
  },

  // a very basic method
  saySomething: function () {
    console.log( "Where in the world is Paul Irish today?" );
  },

  // output a value based on the current configuration
  reportMyConfig: function () {
    console.log( "Caching is: " + ( this.myConfig.useCaching ? "enabled" : "disabled") );
  },

  // override the current configuration
  updateMyConfig: function( newConfig ) {

    if ( typeof newConfig === "object" ) {
      this.myConfig = newConfig;
      console.log( this.myConfig.language );
    }
  }
};

// Outputs: Where in the world is Paul Irish today?
myModule.saySomething();

// Outputs: Caching is: enabled
myModule.reportMyConfig();

// Outputs: fr
myModule.updateMyConfig({
  language: "fr",
  useCaching: false
});

// Outputs: Caching is: disabled
myModule.reportMyConfig();
```

Использование объектных литералов может помочь в инкапсулировании и организации вашего кода.

Тем не менее, если мы выбираем этот метод, мы можем быть в равной степени заинтересованы в шаблоне Module. Он по-прежнему использует объектные литералы, но только как возвращаемое значение из функции области видимости.

Паттерн "Модуль"
----------------

Шаблон модуля изначально определялся как способ обеспечения как частной, так и общедоступной инкапсуляции для классов в обычной программной инженерии.

В JavaScript шаблон модуля используется для дальнейшей эмуляции концепции классов таким образом, что мы можем включать как публичные / частные методы, так и переменные внутри одного объекта, таким образом защищая определенные части от глобальной области. Это приводит к уменьшению вероятности того, что наши имена функций конфликтуют с другими функциями, определенными в дополнительных сценариях на странице.

Шаблон модуля инкапсулирует «приватность», состояние и организацию с помощью замыканий. Он обеспечивает способ объединения нескольких публичных и частных методов и переменных, защищая части от утечки в глобальную область и случайных столкновений с интерфейсами другого разработчика. С этим шаблоном возвращается только открытый API, при этом все остальное скрыто в замыкании.

Следует отметить, что на самом деле в JavaScript не существует явно истинного смысла «приватности», поскольку в отличие от некоторых традиционных языков он не имеет модификаторов доступа. Переменные не могут быть технически объявлены публичными или частными, поэтому мы используем область действия функции для имитации этой концепции. В шаблоне Module объявленные переменные или методы доступны только внутри самого модуля благодаря замыканию. Переменные или методы, определенные в возвращаемом объекте, доступны всем.