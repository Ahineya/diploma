Command
=======
Паттерн "Command" предназначен для инкапсуляции вызова метода, запросов или операций в один объект и дает нам возможность как параметризовать, так и передавать вызовы методов, которые могут быть выполнены по нашему усмотрению. Кроме того, он позволяет отделить объекты, вызывающие действие, от объектов, которые их реализуют, и дает нам большую степень общей гибкости при замене конкретных классов (объектов).

Конкретные классы лучше всего объясняются в терминах языков программирования на основе классов и
связаны с идеей абстрактных классов. Абстрактный класс определяет интерфейс, но необязательно
предоставляет реализации для всех его функций-членов. Он действует как базовый класс,
из которого производятся другие. Производный класс, который реализует недостающую
функциональность, называется конкретным классом.

Общая идея шаблона Command заключается в том, что он предоставляет нам средство для разделения обязанностей по выдаче команд из любых исполняемых команд, делегируя эту ответственность на разные объекты.

Объекты команд последовательно включают в себя операцию выполнения (такую ​​как run() или execute()). Все объекты Command с таким же интерфейсом можно легко поменять по мере необходимости, и это считается одним из больших преимуществ шаблона.

Чтобы продемонстрировать шаблон Command, мы собираемся создать простой сервис покупки автомобилей.

```
(function(){

  var carManager = {

    // request information
    requestInfo: function( model, id ){
      return "The information for " + model + " with ID " + id + " is foobar";
    },

    // purchase the car
    buyVehicle: function( model, id ){
      return "You have successfully purchased Item " + id + ", a " + model;
    },

    // arrange a viewing
    arrangeViewing: function( model, id ){
      return "You have successfully booked a viewing of " + model + " ( " + id + " ) ";
    }

  };

})();
```

Взглянув на приведенный выше код, было бы тривиально вызвать наши методы carManager, непосредственно обратившись к объекту. Мы все были бы прощены за то, что думали, что в этом нет ничего плохого - технически, это полностью допустимый JavaScript. Однако существуют ситуации, когда это может быть невыгодно.

Например, представьте, что основной интерфейс carManager'а изменился.
Это потребовало бы изменения всех объектов, напрямую обращающихся к этим методам в нашем приложении.
Это можно рассматривать как сильную связанность, которая, определённо, идет вразрез с
методологией ООП, которая диктует необходимость слабой связанности объектов.
Вместо этого мы могли бы решить эту проблему, абстрагируя API дальше.

Давайте теперь расширим наш carManager, чтобы наше применение шаблона Command привело к следующему: принять любые именованные методы, которые могут быть выполнены над объектом carManager, передавая любые данные, которые могут использоваться, такие как модель и идентификатор автомобиля.

Вот чего мы хотели бы добиться:

```
carManager.execute( "buyVehicle", "Ford Escort", "453543" );
```

В соответствии с этой структурой теперь мы должны добавить определение для метода carManager.execute следующим образом:

```
carManager.execute = function ( name ) {
    return carManager[name] && carManager[name].apply( carManager, [].slice.call(arguments, 1) );
};
```

Таким образом, наши заключительные примеры вызовов выглядят следующим образом:

```
carManager.execute( "arrangeViewing", "Ferrari", "14523" );
carManager.execute( "requestInfo", "Ford Mondeo", "54323" );
carManager.execute( "requestInfo", "Ford Escort", "34232" );
carManager.execute( "buyVehicle", "Ford Escort", "34232" );
```

