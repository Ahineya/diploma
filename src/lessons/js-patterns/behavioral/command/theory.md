Command
=======
Патерн "Command" призначений для інкапсуляції виклику методу, запитів або операцій в один об'єкт і дає нам можливість як параметризувати, так і передавати виклики методів, які можуть бути виконані на наш розсуд. Крім того, він дозволяє відокремити об'єкти, що викликають дію, від об'єктів, які їх реалізують, і дає нам велику ступінь загальної гнучкості при заміні конкретних класів (об'єктів).
Загальна ідея шаблону Command полягає в тому, що він надає нам засіб для поділу обов'язків з видачі команд з будь-яких виконуваних команд, делегуючи цю відповідальність на різні об'єкти.

Об'єкти команд послідовно включають в себе операцію виконання (таку як run() або execute()). Всі об'єкти Command з таким же інтерфейсом можна легко поміняти в міру необхідності, і це вважається одним з великих переваг шаблону.

Чтобы продемонстрировать шаблон Command, мы собираемся создать простой сервис покупки автомобилей.

```
(function(){

  var carManager = {

    // request information
    requestInfo: function( model, id ){
      return "The information for " + model + " with ID " + id + " is foobar";
    },

    // purchase the car
    buyVehicle: function( model, id ){
      return "You have successfully purchased Item " + id + ", a " + model;
    },

    // arrange a viewing
    arrangeViewing: function( model, id ){
      return "You have successfully booked a viewing of " + model + " ( " + id + " ) ";
    }

  };

})();
```

Взглянув на приведенный выше код, было бы тривиально вызвать наши методы carManager, непосредственно обратившись к объекту. Мы все были бы прощены за то, что думали, что в этом нет ничего плохого - технически, это полностью допустимый JavaScript. Однако существуют ситуации, когда это может быть невыгодно.

Например, представьте, что основной интерфейс carManager'а изменился.
Это потребовало бы изменения всех объектов, напрямую обращающихся к этим методам в нашем приложении.
Это можно рассматривать как сильную связанность, которая, определённо, идет вразрез с
методологией ООП, которая диктует необходимость слабой связанности объектов.
Вместо этого мы могли бы решить эту проблему, абстрагируя API дальше.

Давайте теперь расширим наш carManager, чтобы наше применение шаблона Command привело к следующему: принять любые именованные методы, которые могут быть выполнены над объектом carManager, передавая любые данные, которые могут использоваться, такие как модель и идентификатор автомобиля.

Вот чего мы хотели бы добиться:

```
carManager.execute( "buyVehicle", "Ford Escort", "453543" );
```

В соответствии с этой структурой теперь мы должны добавить определение для метода carManager.execute следующим образом:

```
carManager.execute = function ( name ) {
    return carManager[name] && carManager[name].apply( carManager, [].slice.call(arguments, 1) );
};
```

Таким образом, наши заключительные примеры вызовов выглядят следующим образом:

```
carManager.execute( "arrangeViewing", "Ferrari", "14523" );
carManager.execute( "requestInfo", "Ford Mondeo", "54323" );
carManager.execute( "requestInfo", "Ford Escort", "34232" );
carManager.execute( "buyVehicle", "Ford Escort", "34232" );
```

