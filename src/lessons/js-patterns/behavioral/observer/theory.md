Observer
========
Наблюдатель - это шаблон проектирования, в котором объект (называемый субъектом) ведет список объектов, зависящих от него (наблюдателей), автоматически уведомляя их о любых изменениях состояния.

Когда субъект должен уведомлять наблюдателей о чем-то интересном, он передает уведомление наблюдателям (которые могут включать конкретные данные, относящиеся к теме уведомления).

Когда мы больше не желаем, чтобы конкретный наблюдатель уведомлялся об изменениях субъекта, на которого они зарегистрированы, субъект может удалить их из списка наблюдателей.

Часто полезно ссылаться на опубликованные определения шаблонов проектирования, которые не зависят от языка, чтобы получить более широкое представление об их использовании и преимуществах с течением времени. Определение шаблона наблюдателя, представленное в книге GoF,
«Design Patterns: Elements of Reusable Object-Oriented Software», является следующим:

"Один или несколько наблюдателей интересуются состоянием предмета и регистрируют свой интерес к предмету, присоединяясь к нему. Когда что-то меняется в нашей теме, что может заинтересовать наблюдателя, посылается сообщение-уведомление, которое вызывает метод обновления в каждом наблюдателе. Когда наблюдателя больше не интересует состояние субъекта, они могут просто отделить себя."

Теперь мы можем расширить то, что мы узнали, для реализации шаблона Observer со следующими компонентами:

* Subject: ведет список наблюдателей, облегчает добавление или удаление наблюдателей
* Observer: предоставляет интерфейс обновления для объектов, которые должны быть уведомлены об изменениях состояния объекта
* ConcreteSubject: отправляет уведомления наблюдателям об изменениях состояния, сохраняет состояние ConcreteObservers
* ConcreteObserver: хранит ссылку на ConcreteSubject, реализует интерфейс обновления для наблюдателя, чтобы гарантировать соответствие состояния объекта Subject

Во-первых, давайте смоделируем список зависимых наблюдателей, которые субъект может иметь:

```
function ObserverList(){
  this.observerList = [];
}

ObserverList.prototype.add = function( obj ){
  return this.observerList.push( obj );
};

ObserverList.prototype.count = function(){
  return this.observerList.length;
};

ObserverList.prototype.get = function( index ){
  if( index > -1 && index < this.observerList.length ){
    return this.observerList[ index ];
  }
};

ObserverList.prototype.indexOf = function( obj, startIndex ){
  var i = startIndex;

  while( i < this.observerList.length ){
    if( this.observerList[i] === obj ){
      return i;
    }
    i++;
  }

  return -1;
};

ObserverList.prototype.removeAt = function( index ){
  this.observerList.splice( index, 1 );
};
```

Далее давайте смоделируем тему и возможность добавлять, удалять или уведомлять наблюдателей в списке.

```
function Subject(){
  this.observers = new ObserverList();
}

Subject.prototype.addObserver = function( observer ){
  this.observers.add( observer );
};

Subject.prototype.removeObserver = function( observer ){
  this.observers.removeAt( this.observers.indexOf( observer, 0 ) );
};

Subject.prototype.notify = function( context ){
  var observerCount = this.observers.count();
  for(var i=0; i < observerCount; i++){
    this.observers.get(i).update( context );
  }
};
```

Затем мы определяем скелет для создания новых наблюдателей. Функция обновления здесь будет перезаписана позже с собственным поведением.

```
// The Observer
function Observer(){
  this.update = function(){
    // ...
  };
}
```

В нашем примере приложения, использующего вышеупомянутые компоненты Observer, мы теперь определяем:

* Кнопка добавления новых заметных флажков на страницу
* Флажок элемента управления, который будет действовать как тема, уведомляя другие флажки, они должны быть проверены
* Добавляется контейнер для добавления новых флажков
Затем мы определяем обработчики ConcreteSubject и ConcreteObserver для добавления
новых наблюдателей на страницу и реализации интерфейса обновления.


