Facade
======

Когда мы устанавливаем фасад, мы представляем внешний вид миру, который может скрыть совсем другую реальность. Это послужило вдохновением для названия следующего шаблона, который мы собираемся рассмотреть - шаблон Facade. Этот шаблон обеспечивает удобный интерфейс более высокого уровня для большей части кода, скрывая его истинную базовую сложность. Думайте об этом как об упрощении предоставления API другим разработчикам, что почти всегда повышает удобство использования.

Фасады являются структурной моделью, которую часто можно увидеть в библиотеках JavaScript, таких как jQuery, где, хотя реализация может поддерживать методы с широким диапазоном поведения, а для публичного использования используется «фасад» как ограниченная абстракция этих методов.

Это позволяет нам напрямую взаимодействовать с Facade, а не с подсистемой. Всякий раз, когда мы используем методы jQuery $(el).css() или $(el).animate (), мы фактически используем Facade - более простой публичный интерфейс, который позволяет избежать необходимости вручную обращаться к многим внутренним методам в ядре jQuery. Чтобы заставить некоторое поведение работать. Это также позволяет избежать необходимости вручную взаимодействовать с DOM API и поддерживать переменные состояния.

Основные методы jQuery следует рассматривать как промежуточные абстракции. Более непосредственное бремя для разработчиков - DOM API, а фасады - вот что делает библиотеку jQuery настолько простой в использовании.

Шаблон Facade упрощает интерфейс класса, а также отделяет класс от кода, который его использует.
Это дает нам возможность косвенно взаимодействовать с подсистемами таким способом, который иногда
может быть менее подвержен ошибкам, чем прямой доступ к подсистеме. Преимущества Facade включают
простоту использования и часто малый размер в реализации шаблона.

Давайте посмотрим на шаблон в действии. Это неоптимизированный пример кода, но здесь мы используем Facade для упрощения интерфейса для
кросс-браузерного прослушивания событий. Мы делаем это, создавая общий метод, который можно использовать в
своем коде, который выполняет задачу проверки наличия функций, чтобы обеспечить безопасное и совместимое с браузерами решение.

```
var addMyEvent = function( el,ev,fn ){

   if( el.addEventListener ){
            el.addEventListener( ev,fn, false );
      }else if(el.attachEvent){
            el.attachEvent( "on" + ev, fn );
      } else{
           el["on" + ev] = fn;
    }

};
```

Аналогичным образом, мы все знакомы с $(document)ready(..) из jQuery.
Изнутри это фактически приводится в действие методом, названным bindReady(), который делает это:

```
bindReady: function() {
    ...
    if ( document.addEventListener ) {
      // Use the handy event callback
      document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

      // A fallback to window.onload, that will always work
      window.addEventListener( "load", jQuery.ready, false );

    // If IE event model is used
    } else if ( document.attachEvent ) {

      document.attachEvent( "onreadystatechange", DOMContentLoaded );

      // A fallback to window.onload, that will always work
      window.attachEvent( "onload", jQuery.ready );
               ...
```

Однако фасады не обязательно должны использоваться сами по себе. Они также могут быть объединены с другими шаблонами, такими как шаблон модуля. Как мы можем видеть ниже, наш экземпляр шаблонов модулей содержит ряд методов, которые были определены в частном порядке. Затем Facade используется для предоставления гораздо более простого API для доступа к этим методам:

```
var module = (function() {

    var _private = {
        i: 5,
        get: function() {
            console.log( "current value:" + this.i);
        },
        set: function( val ) {
            this.i = val;
        },
        run: function() {
            console.log( "running" );
        },
        jump: function(){
            console.log( "jumping" );
        }
    };

    return {

        facade: function( args ) {
            _private.set(args.val);
            _private.get();
            if ( args.run ) {
                _private.run();
            }
        }
    };
}());


// Outputs: "current value: 10" and "running"
module.facade( {run: true, val: 10} );
```

В этом примере вызов module.facade () фактически инициирует набор частных действий в модуле, но опять же, пользователь не имеет к этому никакого отношения. Мы упростили их использование без необходимости беспокоиться о деталях на уровне реализации.

